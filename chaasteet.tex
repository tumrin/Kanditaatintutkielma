\chapter{C-kielien haasteet} \label{C-kielien haasteet}
Tässä luvussa esitellään C- ja \Cpp-ohjelmointikielissä tyypillisesti esiintyviä haasteita, niiden juurisyitä sekä niistä aiheutuvia seurauksia ohjelmien toiminnassa. Luvussa perustellaan, miksi C- ja \Cpp-kielien korvaamista olisi syytä harkita. Lisäksi luvussa esitellään tapoja, joilla näitä ongelmia on pyritty ratkaisemaan.

\section{Muistinhallinta}
C-ohjelmointikielessä muistinhallinta tapahtuu manuaalisesti hyödyntämällä pääasiassa \textit{malloc}- ja \textit{free}-komentoja. \Cpp-kielessä puolestaan käytetään \textit{new}- ja \textit{delete}-komentoja, jotka kutsuvat luokkien konstruktori- ja dekonstruktorifunktioita. Manuaalisesta muistinhallinnasta saattaa koitua ongelmia, sillä ohjelmoija voi unohtaa vapauttaa muistin, mikä aiheuttaa muistivuodon sovelluksessa, tai yrittää vapauttaa jo vapautetun muistin, mikä johtaa puolestaan määrittelemättömään käyttäytymiseen sovelluksessa~\cite{cppfree}. Lisäksi ongelmia aiheutuu tilanteesta, jossa ohjelmoija yrittää käyttää muistialuetta, jota ei ole alustettu. Tyypillinen virhe on yritys käyttää taulukolle varatun muistialueen ulkopuolista indeksiä, mikä johtaa myös ohjelman määrittelemättömään käyttäytymiseen. Varatun muistialueen ulkopuolelle kirjoittaminen voi johtua puskurin yli- tai alivuodosta (engl. buffer overflow and buffer underflow), jossa tietyn kokoiseen puskuriin yritetään kirjoittaa puskurin kokoa suurempi määrä tietoa tai päästä käsiksi muistialueeseen ennen puskurin alkua. Puskurin yli- ja alivuoto ovat yleisiä vakavien tietoturva-aukkojen aiheuttajia ja niitä käytetäänkin monissa hyökkäyksissä hyödyksi~\cite{cwetop25}.

Muistinhallinnan virheet johtavat usein erilaisiin tietoturva-aukkoihin. Microsoftin Security Response Center -palvelun mukaan noin 70\text{\%} vuosittain löydetyistä tietoturva-aukoista johtuu muistinhallintaan liittyvistä ongelmista~\cite{microsoftProactiveApproach}. Myös yksi Servo-selainmottorin kehittäjistä on päätynyt vastaaviin tuloksiin tutkiessaan Rust-ohjelmointikielen käyttöä selaimen osissa. Tutkimuksen tuloksena havaittiin, että kyseisessä osassa 32 kriittistä haavoittuvuutta 34:stä johtui virheellisestä muistinhallinnasta~\cite{quantumcss}.

C- ja \Cpp-kielien muistinhallintaa avustamaan on kehitetty erilaisia ohjelmointitekniikoita, työkaluja, kirjastoja ja päivityksiä itse ohjelmointikieleen. Dynaamista muistinhallintaa käytettäessä C-kielessä tulee muisti aina vapauttaa \textit{free}-komennolla, kun sitä ei tarvita enää. Lisäksi on suositeltavaa asettaa vapautettu osoitin null-arvoon, jotta sen käytön yrittäminen myöhemmin aiheuttaisi välittömän virheen eikä johtaisi määrittelemättömään käyttäytymiseen.

\Cpp -kielessä on yleisesti käytössä RAII eli Resource Acquisition Is Initialization-ohjelmointitekniikka. RAII-tekniikassa luokassa on konstruktori ja destruktori, jotka varaavat ja vapauttavat tarvittavan muistin. Näitä muistialueita käsitellään vain luokan metodien puitteissa, jolloin mahdollisuus virheelliseen muistinhallintaan pienenee huomattavasti. RAII-tekniikassa muistin varaus on olemassa siis yhtä kauan kuin sen varaava objekti. RAII-tekniikan käyttöön sisältyy myös usein \Cpp:n standardikirjastosta löytyvien älykkäiden osoittimien (eng. Smart pointer) tai lukkojen käyttö~\cite{raii}. RAII auttaa vähentämään muistinhallinnan virheitä, mutta se ei kuitenkaan estä ohjelmoijaa tekemästä virheitä muistinhallinnassa. Lisäksi ohjelmoija voi päättää olla käyttämättä RAII-tekniikkaa. Ohjelmalistaukset \ref{RAII_example} ja \ref{RAII_example1} näyttävät esimerkkejä RAII-tekniikan käytöstä \Cpp:ssa. Ohjelmalistauksessa \ref{RAII_example1} käytetään älykästä osoitinta, jonka konstruktori ja dekonstruktori hoitavat muistin varaamisen ja vapauttamisen, jolloin muistinhallintaa ei tarvitse erikseen tehdä.

\begin{minipage}{\linewidth}
\lstinputlisting[language=C++, caption=RAII esimerkki~\cite{corob-msft}., label={RAII_example}]{koodiesimerkit/raii.cpp} 
\end{minipage}

\begin{minipage}{\linewidth}
\lstinputlisting[language=C++, caption=RAII esimerkki käyttämällä älykkäitä osoittimia~\cite{corob-msft}., label={RAII_example1}]{koodiesimerkit/raiisp.cpp}
\end{minipage}

\section{Säikeet}
Säikeiden käytölle tyypillisiä haasteita ovat kilpailutilanne (engl. race condition) ja lukkiutumistilanne (engl. deadlock). Kilpailutilanteessa kaksi eri säiettä yrittävät lukea tai kirjoittaa samaa muistialuetta, jolloin on mahdollista, että muistipaikkaan jää vanha arvo tai toinen säikeistä lukee väärän arvon, mikä johtaa ohjelman virheelliseen toimintaan. Lukkiutumistilanteessa kaksi eri säiettä ovat riippuvaisia toistensa lukkiutuvista resursseista, jolloin kumpikin säie odottaa, että toinen vapauttaa lukitun resurssin voidakseen edetä, mikä johtaa ohjelman jäämiseen lukkotilaan.

Säikeiden käyttö voi lisätä ohjelman nopeutta, mutta se lisää myös ohjelmoinnin monimutkaisuutta, jolloin mahdollisuus ohjelmoijan virheisiin kasvaa. Lisäksi säikeiden käytöstä johtuvia ongelmia koodissa on hyvin vaikea havaita testauksessa, johtuen monen ohjelman osan samanaikaisesta suorittamisesta. Eräässä samanaikaisuusongelmien tutkimuksessa havaittiin, että 49\text{\%} 1134:stä tutkimuksen TSVD eli thread safety violation detector -ohjelman löytämästä ongelmasta johtui siitä, että usean säikeen käyttämä resurssi lukittiin kirjoitettaessa, mutta ei sitä luettaessa~\cite[p.~172]{10.1145/3341301.3359638}. Nykyään monissa sovelluksissa säikeiden käyttö on kuitenkin välttämätöntä korkeiden suorituskykyvaatimusten takia. Lisäksi ydinten ja käytössä olevien säikeiden määrä prosessoreissa kasvaa jatkuvasti rajan tullessa vastaan yhden ytimen nopeudessa.

Säikeiden käyttöä varten on kehitetty lukkoja ja älykkäitä osoittimia, joiden tarkoituksena on estää kilpailutilanteet säikeiden välillä. Esimerkiksi Mutex-tyypillä voidaan estää kilpailutilanteet säikeiden välillä. Ohjelmoija voi kuitenkin päättää olla käyttämättä Mutexia tai unohtaa sen käytön, mikä voi johtaa edellä mainittuun kilpailutilanteeseen. Tyypillinen virhe on myös käyttää Mutexia resurssin lukitsemiseen, mutta unohtaa sen vapauttaminen. 

Ohjelmalistaus \ref{thread_example_c} esittelee yksinkertaisen esimerkin säikeiden käytöstä. Listauksessa \textit{increment\_counter}-funktio ei ole säieturvallinen, sillä kaikki säikeet voivat samanaikaisesti muokata \textit{counter}-muuttujaa. Alemmassa \textit{increment\_counter\_locked}-funktiossa käytetään mutex-lukkoa varmistamaan, että vain yksi säie kerrallaan voi muokata \textit{counter}-muuttujaa.

\begin{minipage}{\linewidth}
\lstinputlisting[language=c, caption=Säikeiden käyttö C-kielessä. Ohjelmoijan on mahdollista luoda kilpailutilanne., label={thread_example_c}]{koodiesimerkit/thread.c}
\end{minipage}

\section{Tyypitys}
C on staattisesti, mutta ei vahvasti tyypitetty ohjelmointikieli, vaikka siihen onkin ajan myötä lisätty tyyppijärjestelmää vahvistavia sääntöjä~\cite[p.~3]{Cbook}. C:n tyyppijärjestelmä voi aiheuttaa ongelmia esimerkiksi tilanteessa, jossa void-osoitin laitetaan osoittamaan eri tyyppiin, kuin mihin se oli aiemmin osoitettu. Void-osoittimien käyttöä onkin syytä välttää, jos mahdollista. Kaikkien osoittimien käyttö vaatii ohjelmoijalta tarkkuutta, sillä se voi aiheuttaa roikkuvan osoittimen (engl. dangling pointer), eli osoittimen, jonka osoittama muistialue on vapautettu tai otettu uudelleen käyttöön eri resurssille. 

\Cpp-kieli on C:n tavoin staattisesti tyypitetty ja tyyppijärjestelmä on C-kieltä tarkempi, joten monet C:ssä mahdolliset virheet eivät onnistu \Cpp:ssa. Lisäksi \Cpp-tyypitys nojaa vahvasti käännöksenaikaiseen tarkistukseen~\cite[p.~13-14]{Cppbook}. Void-osoitin on kuitenkin käytössä \Cpp:ssa, jossa sen käyttöä ei myöskään suositella, mikäli sitä voidaan välttää. Lisäksi roikkuva osoitin on mahdollinen ongelma myös \Cpp:ssa.

Nullia eli puuttuvaa arvoa kuvaava tyyppi on tyypillisesti aiheuttanut ongelmia ja null-viittauksien sallimista onkin kutsuttu "miljardin dollarin virheeksi"~niiden aiheuttamien lukuisien virheiden, haavoittuvuuksien ja ohjelmien epävakauden takia~\cite{infoqnull}. Null-arvo aiheuttaa ongelmia esimerkiksi tilanteessa, jossa käytettävän muuttujan arvo on null eikä ohjelmoija tarkista arvoa ennen sen käyttöä ohjelmassaan.

\section{Kirjastot}
Kuten luvussa \ref{kirjastot} mainittiin, C-kielille ei ole keskitettyä pakettihallintajärjestelmää riippuvuuksien ja kolmannen osapuolten kirjastojen käyttöön. Lisäksi huolimatta kolmannen osapuolten sovelluksista, kuten Conan-pakettihallintasovelluksesta, ei kirjastojen ympärille ole kehittynyt laajaa ekosysteemiä~\cite{WOS:000449166500015}. Tämä puolestaan voi johtaa hankaluuksiin kirjastojen löytämisessä, sekä tekee niiden versioiden päivittämisestä työläämpää verrattuna keskitettyyn rekisteriin perustuvaan pakettihallintaratkaisuun.

Kirjastojen päivittäminen on tärkeää, sillä tuotannossa oleviin sovelluksiin saattaa usein tulla tietoturva-aukkoja ja muita ongelmia juuri kolmannen osapuolen kirjastojen kautta. Tämä johtuu siitä, että monissa sovelluksia kirjastoja päivitetään harvoin~\cite{veracode}, minkä takia kirjastojen versionhallinnan tulisi olla mahdollisimman vaivatonta. Lisäksi kirjastojen versionhallinta on hyödyllistä, sillä joskus uusi päivitys voi rikkoa kirjaston, jolloin aiempaan versioon palaaminen on voitava tehdä sujuvasti.