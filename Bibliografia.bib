@book{Cbook,
    author = {Kernighan, Brian W. and Ritchie, Dennis M.},
    title = {The  C Programming Language},
    year = {1988},
    isbn = {0131103709},
    publisher = {Prentice Hall Professional Technical Reference},
    edition = {2nd},
    abstract = {From the Publisher: This second editon describes C as defined by the ANSI standard. This book is meant to help the reader learn how to program in C. The book assumes some familiarity with basic programming concepts like variables, assignment statements, loops, and functions. A novice programmer should be able to read along and pick up the language. FEATURES: All examples have been tested, which is in machine-readable form. It discusses various aspects of C in more detail, although the emphasis is on examples of complete programs, rather than isolated fragments. It deals with basic data types, operators and expressions. Covers functions and program structure, external variables, scope rules, multiple source files, and also touches on the preprocessor. It also describes an interface between C programs and the UNIX operating system, concentrating on input/output, the file system, and storage allocation. It also provides a language reference manual. The official statement of the syntax and semantics of C is the ANSI standard.}
}

@book{Cppbook,
    author = {Stroustrup, Bjarne},
    title = {The C++ Programming Language},
    year = {2013},
    isbn = {0321563840},
    publisher = {Addison-Wesley Professional},
    edition = {4th},
    abstract = {C++11 has arrived: thoroughly master it, with the definitive new guide from C++ creator Bjarne Stroustrup, C++ Programming Language, Fourth Edition! The brand-new edition of the world's most trusted and widely read guide to C++, it has been comprehensively updated for the long-awaited C++11 standard. Extensively rewritten to present the C++11 language, standard library, and key design techniques as an integrated whole, Stroustrup thoroughly addresses changes that make C++11 feel like a whole new language, offering definitive guidance for leveraging its improvements in performance, reliability, and clarity. C++ programmers around the world recognize Bjarne Stoustrup as the go-to expert for the absolutely authoritative and exceptionally useful information they need to write outstanding C++ programs. Now, as C++11 compilers arrive and development organizations migrate to the new standard, they know exactly where to turn once more: Stoustrup's C++ Programming Language, Fourth Edition.}
}

@misc{mozillarust,
    title={Rust --- Mozilla research},
    url={https://research.mozilla.org/rust/},
    journal={Mozilla Research},
    note = {[Accessed 02-Mar-2022]}
} 

@misc{rust1blog,
    title={Announcing Rust 1.0: Rust blog},
    url={https://blog.rust-lang.org/2015/05/15/Rust-1.0.html}, 
    journal={The Rust Programming Language Blog},
    note = {[Accessed 1-Feb-2022]}
} 

@misc{rustbook,
    author = {Klabnik, Steve and Nichols, Carol},
    title = {{The Rust Programming Language}},
    howpublished = {\url{https://doc.rust-lang.org/stable/book/}},
}

 @misc{rustkernel,
     title={Linux kernel mailing list --- Rust support},
     url={https://lore.kernel.org/lkml/20220317181032.15436-1-ojeda@kernel.org/},
     journal={[patch V5 00/20] rust support - miguel ojeda}
 } 

@misc{servo,
    title={Servo},
    url={https://servo.org/},
    journal={Servo},
    note = {[Accessed 02-Mar-2022]}
}

@misc{webassembly,
    title={WebAssembly Developer's Guide},
    url={https://webassembly.org/getting-started/developers-guide/},
    journal={WebAssembly},
    note = {[Accessed 02-Mar-2022]}
}

@misc{gcctarget,
    title={Host/Target specific installation notes for GCC},
    url={https://gcc.gnu.org/install/specific.html},
    journal={Host/Target specific installation notes for GCC - GNU Project},
    note = {[Accessed 02-Mar-2022]}
}

@misc{rustc,
    title={The Rustc book},
    url={https://doc.rust-lang.org/stable/rustc/platform-support.html},
    journal={Platform Support - The rustc book},
    note = {[Accessed 02-Mar-2022]}
} 

@misc{esprs,
    title={Rust for the XTENSA architecture},
    url={https://github.com/esp-rs/rust},
    journal={GitHub},
    author={esp-rs},
    note = {[Accessed 02-Mar-2022]}
}

@misc{rustvsc,
    title={Rust costs versus C gcc costs},
    url={https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust.html},
    journal={Rust&nbsp;vs&nbsp;C gcc - Which programs are fastest?},
    note = {[Accessed 02-Mar-2022]}
}

@misc{cppfree,
    title={Free},
    howpublished={\url{https://en.cppreference.com/w/c/memory/free}},
    note = {[Accessed 02-Mar-2022]}
}

@misc{cargo,
    title={The Cargo book},
    url={https://doc.rust-lang.org/cargo/guide/dependencies.html},
    journal={Dependencies - The Cargo Book},
    note = {[Accessed 27-Mar-2022]}
} 

@misc{microsoftProactiveApproach,
    author = {{MSRC Team}},
    title = {{A} proactive approach to more secure code},
    howpublished = {\url{https://msrc-blog.microsoft.com/2019/07/16/a-proactive-approach-to-more-secure-code/}},
    year = {2019},
    note = {[Accessed 02-Mar-2022]},
}

@misc{quantumcss, 
    title={Implications of rewriting a browser component in Rust --- Mozilla hacks --- the web developer blog}, 
    howpublished ={\url{https://hacks.mozilla.org/2019/02/rewriting-a-browser-component-in-rust/}}, journal={Mozilla Hacks - the Web developer blog}, 
    author={Diane Hosfelt}, 
    note = {[Accessed 02-Mar-2022]}
} 

@misc{raii,
    title={RAII},
    url={https://en.cppreference.com/w/cpp/language/raii},
    journal={cppreference.com},
    note = {[Accessed 16-Mar-2022]}
} 

@article{10.1145/3485498,
    author = {Emre, Mehmet and Schroeder, Ryan and Dewey, Kyle and Hardekopf, Ben},
    title = {Translating C to Safer Rust},
    year = {2021},
    issue_date = {October 2021},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {5},
    number = {OOPSLA},
    doi = {10.1145/3485498},
    abstract = {Rust is a relatively new programming language that targets efficient and safe systems-level applications. It includes a sophisticated type system that allows for provable memory- and thread-safety, and is explicitly designed to take the place of unsafe languages such as C and C++ in the coding ecosystem. There is a large existing C and C++ codebase (many of which have been affected by bugs and security vulnerabilities due to unsafety) that would benefit from being rewritten in Rust to remove an entire class of potential bugs. However, porting these applications to Rust manually is a daunting task.  In this paper we investigate the problem of automatically translating C programs into safer Rust programs--that is, Rust programs that improve on the safety guarantees of the original C programs. We conduct an in-depth study into the underlying causes of unsafety in translated programs and the relative impact of fixing each cause. We also describe a novel technique for automatically removing a particular cause of unsafety and evaluate its effectiveness and impact. This paper presents the first empirical study of unsafety in translated Rust programs (as opposed to programs originally written in Rust) and also the first technique for automatically removing causes of unsafety in translated Rust programs.},
    journal = {Proc. ACM Program. Lang.},
    month = {oct},
    articleno = {121},
    numpages = {29},
    keywords = {Memory-Safety, C, Rust, Automatic Translation, Empirical Study}
}

@inproceedings{WOS:000449166500015,
    Author = {Kyriakou, Kyriakos-Ioannis D. and Tselikas, Nikolaos D. and Kapitsaki,
       Georgia M.},
    Editor = {Stamelos, I and GonzalezBarahona, JM and Varlamis, I and Anagnostopoulos, D},
    Title = {Improving C/C plus plus Open Source Software Discoverability by
       Utilizing Rust and Node.js Ecosystems},
    Booktitle = {OPEN SOURCE SYSTEMS: ENTERPRISE SOFTWARE AND SOLUTIONS, OSS 2018},
    Series = {IFIP Advances in Information and Communication Technology},
    Year = {2018},
    Volume = {525},
    Pages = {181-192},
    Note = {14th IFIP WG 2.13 International Conference on Open Source Systems (OSS),
       Athens, GREECE, JUN 08-10, 2018},
    Organization = {Harokopio Univ; IFIP WG 2 13},
    DOI = {10.1007/978-3-319-92375-8\_15},
    ISSN = {1868-4238},
    EISSN = {1868-422X},
    ISBN = {978-3-319-92375-8; 978-3-319-92374-1},
    ORCID-Numbers = {Tselikas, Nikolaos/0000-0001-5799-3558},
    Unique-ID = {WOS:000449166500015},
}

@inproceedings{rustgc,
    author = {Lin, Yi and Blackburn, Stephen M. and Hosking, Antony L. and Norrish, Michael},
    title = {Rust as a Language for High Performance GC Implementation},
    year = {2016},
    isbn = {9781450343176},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    doi = {10.1145/2926697.2926707},
    abstract = { High performance garbage collectors build upon performance-critical low-level code, typically exhibit multiple levels of concurrency, and are prone to subtle bugs. Implementing, debugging and maintaining such collectors can therefore be extremely challenging. The choice of implementation language is a crucial consideration when building a collector. Typically, the drive for performance and the need for efficient support of low-level memory operations leads to the use of low-level languages like C or C++, which offer little by way of safety and software engineering benefits. This risks undermining the robustness and flexibility of the collector design. Rust's ownership model, lifetime specification, and reference borrowing deliver safety guarantees through a powerful static checker with little runtime overhead. These features make Rust a compelling candidate for a collector implementation language, but they come with restrictions that threaten expressiveness and efficiency. We describe our experience implementing an Immix garbage collector in Rust and C. We discuss the benefits of Rust, the obstacles encountered, and how we overcame them. We show that our Immix implementation has almost identical performance on micro benchmarks, compared to its implementation in C, and outperforms the popular BDW collector on the gcbench micro benchmark. We find that Rust's safety features do not create significant barriers to implementing a high performance collector. Though memory managers are usually considered low-level, our high performance implementation relies on very little unsafe code, with the vast majority of the implementation benefiting from Rust's safety. We see our experience as a compelling proof-of-concept of Rust as an implementation language for high performance garbage collection. },
    booktitle = {Proceedings of the 2016 ACM SIGPLAN International Symposium on Memory Management},
    pages = {89–98},
    numpages = {10},
    keywords = {Rust, memory management, garbage collection},
    location = {Santa Barbara, CA, USA},
    series = {ISMM 2016}
}

@inproceedings{10.1145/3341301.3359638,
    author = {Li, Guangpu and Lu, Shan and Musuvathi, Madanlal and Nath, Suman and Padhye, Rohan},
    title = {Efficient Scalable Thread-Safety-Violation Detection: Finding Thousands of Concurrency Bugs during Testing},
    year = {2019},
    isbn = {9781450368735},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    doi = {10.1145/3341301.3359638},
    abstract = {Concurrency bugs are hard to find, reproduce, and debug. They often escape rigorous in-house testing, but result in large-scale outages in production. Existing concurrency-bug detection techniques unfortunately cannot be part of industry's integrated build and test environment due to some open challenges: how to handle code developed by thousands of engineering teams that uses a wide variety of synchronization mechanisms, how to report little/no false positives, and how to avoid excessive testing resource consumption.This paper presents TSVD, a thread-safety violation detector that addresses these challenges through a new design point in the domain of active testing. Unlike previous techniques that inject delays randomly or employ expensive synchronization analysis, TSVD uses lightweight monitoring of the calling behaviors of thread-unsafe methods, not any synchronization operations, to dynamically identify bug suspects. It then injects corresponding delays to drive the program towards thread-unsafe behaviors, actively learns from its ability or inability to do so, and persists its learning from one test run to the next. TSVD is deployed and regularly used in Microsoft and it has already found over 1000 thread-safety violations from thousands of projects. It detects more bugs than state-of-the-art techniques, mostly with just one test run.},
    booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
    pages = {162–180},
    numpages = {19},
    keywords = {thread-safety violation, scalability, debugging, reliability, concurrency bugs},
    location = {Huntsville, Ontario, Canada},
    series = {SOSP '19}
}

@report{veracode,
    author={{Veracode}},
    title = {State of Software Security: Volume 11 Open Source Edition},
    year = {2021},
    url={https://info.veracode.com/fy22-state-of-software-security-v11-open-source-edition.html},
    publisher = {Veracode}
}

@misc{corob-msft,
     title={Object lifetime and resource management (RAII)}, url={https://docs.microsoft.com/en-us/cpp/cpp/object-lifetime-and-resource-management-modern-cpp?view=msvc-170}, journal={Microsoft Docs}, author={Microsoft}
 } 
 
@article{10.1145/3418295,
    author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
    title = {Safe Systems Programming in Rust},
    year = {2021},
    issue_date = {April 2021},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {64},
    number = {4},
    issn = {0001-0782},
    doi = {10.1145/3418295},
    abstract = {The promise and the challenges of the first industry-supported language to master the trade-off between safety and control.},
    journal = {Commun. ACM},
    month = {mar},
    pages = {144–152},
    numpages = {9}
}

@INPROCEEDINGS{unsafe,
    author={Evans, Ana Nora and Campbell, Bradford and Soffa, Mary Lou},
    booktitle={2020 IEEE/ACM 42nd International Conference on Software Engineering (ICSE)},
    title={Is Rust Used Safely by Software Developers?},
    year={2020},
    volume={},
    number={},
    pages={246-257},
    doi={}
}

@article{rustbelt,
    author = {Jung, Ralf and Jourdan, Jacques-Henri and Krebbers, Robbert and Dreyer, Derek},
    title = {RustBelt: Securing the Foundations of the Rust Programming Language},
    year = {2017},
    issue_date = {January 2018},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {2},
    number = {POPL},
    doi = {10.1145/3158154},
    abstract = {Rust is a new systems programming language that promises to overcome the seemingly fundamental tradeoff between high-level safety guarantees and low-level control over resource management. Unfortunately, none of Rust's safety claims have been formally proven, and there is good reason to question whether they actually hold. Specifically, Rust employs a strong, ownership-based type system, but then extends the expressive power of this core type system through libraries that internally use unsafe features. In this paper, we give the first formal (and machine-checked) safety proof for a language representing a realistic subset of Rust. Our proof is extensible in the sense that, for each new Rust library that uses unsafe features, we can say what verification condition it must satisfy in order for it to be deemed a safe extension to the language. We have carried out this verification for some of the most important libraries that are used throughout the Rust ecosystem.},
    journal = {Proc. ACM Program. Lang.},
    month = {dec},
    articleno = {66},
    numpages = {34},
    keywords = {concurrency, type systems, separation logic, Rust, logical relations}
}

@article{rustformalism,
    author = {Pearce, David J.},
    title = {A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust},
    year = {2021},
    issue_date = {March 2021},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {43},
    number = {1},
    issn = {0164-0925},
    doi = {10.1145/3443420},
    abstract = {Rust is a relatively new programming language that has gained significant traction since its v1.0 release in 2015. Rust aims to be a systems language that competes with C/C++. A claimed advantage of Rust is a strong focus on memory safety without garbage collection. This is primarily achieved through two concepts, namely, reference lifetimes and borrowing. Both of these are well-known ideas stemming from the literature on region-based memory management and linearity/uniqueness. Rust brings both of these ideas together to form a coherent programming model. Furthermore, Rust has a strong focus on stack-allocated data and, like C/C++ but unlike Java, permits references to local variables.Type checking in Rust can be viewed as a two-phase process: First, a traditional type checker operates in a flow-insensitive fashion; second, a borrow checker enforces an ownership invariant using a flow-sensitive analysis. In this article, we present a lightweight formalism that captures these two phases using a flow-sensitive type system that enforces “type and borrow safety.” In particular, programs that are type and borrow safe will not attempt to dereference dangling pointers. Our calculus core captures many aspects of Rust, including copy- and move-semantics, mutable borrowing, reborrowing, partial moves, and lifetimes. In particular, it remains sufficiently lightweight to be easily digested and understood and, we argue, still captures the salient aspects of reference lifetimes and borrowing. Furthermore, extensions to the core can easily add more complex features (e.g., control-flow, tuples, method invocation). We provide a soundness proof to verify our key claims of the calculus. We also provide a reference implementation in Java with which we have model checked our calculus using over 500B input programs. We have also fuzz tested the Rust compiler using our calculus against 2B programs and, to date, found one confirmed compiler bug and several other possible issues.},
    journal = {ACM Trans. Program. Lang. Syst.},
    month = {apr},
    articleno = {3},
    numpages = {73},
    keywords = {Rust, type theory, ownership, model checking}
}

@online{infoqnull,
    title = {Null References: The Billion Dollar Mistake},
    date = {2009},
    organization = {InfoQ},
    author = {Tony Hoare},
    url = {https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/},
}

@misc{cwetop25,
    author = {Adam Chaudry and Steve Christey Coley and Kerry Crouse and Kevin Davis and Devon Ellis and Parker Garrison and Christina Johns and Luke Malinowski and Rushi Purohit and Becky Powell and David Rothenberg and Alec Summers and Brian Vohaska and Christopher Turner and Robert Byers and Vidya Ananthakrishna},
    title = {2021 CWE Top 25 Most Dangerous Software Weaknesses},
    date = {2021},
    url = {https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html}
}

@misc{rustfaq,
    title = {The Rust Design FAQ},
    url = {https://doc.rust-lang.org/1.2.0/complement-design-faq.html},
    note = {[Accessed 10-Apr-2022]}
}
@misc{rustfoundation,
    title={Hello World! Announcing the Rust Foundation to the World},
    url={https://foundation.rust-lang.org/news/2021-02-08-hello-world/},
    note = {[Accessed 13-Apr-2022]}
}